# 사전과제

원티드 프리온보딩 4차 백엔드 챌린지 사전과제. 11월 30일까지 제출.

**목차**

1. 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
2. 블로킹과 논블로킹의 차이점을 설명해주세요.
3. 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
4. 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
5. 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)

## 1. 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
동기와 비동기는 데이터를 처리하는 방법을 나타냅니다.

### 동기 처리

동기 처리는 데이터를 순차적으로 처리하는 방식입니다. 이 방식은 선행중인 작업이 완료되기 전까지 후행 작업들은 모두 대기해야 합니다.

예를 들어, 동기 처리방식의 서버에 작업 1, 2, 3이 동시에 요청되었고, 이 서버는 작업 1을 처리하고 있다고 가정해봅니다. 작업 1, 2, 3은 처리에 약 30초가 소요됩니다. 이 경우 작업 2는 30초를, 작업 3은 1분을 기다려야 처리를 시작할 수 있습니다. 서버에 요청된 모든 작업들이 완료되는데 총 1분 30초가 소요되었습니다.

- 0초 - 작업 1,2,3 요청
- 30초 - 작업 1 완료, 2, 3 대기
- 60초 - 작업 2 완료, 3 대기
- 90초 - 작업 3 완료

### 비동기 처리

동기 처리와 반해, 비동기는 데이터를 순차적으로 처리하지 않습니다. 비동기 처리 방식은 요청이 발생되면 별도의 쓰레드에서 작업을 수행합니다. 후행 작업들은 대기시간 없이 즉시 처리를 시작할 수 있습니다. 비동기 작업들은 처리가 완료된 즉시 결과값을 반환합니다.

예를들어 비동기처리방식의 서버에 작업 1,2,3이 동시에 요청된다고 가정해 봅니다. 작업 1, 2, 3은 처리에 각 10초, 20초, 30초가 소요됩니다. 서버는 작업 1, 2, 3을 별도의 쓰레드에서 처리합니다. 그 결과 요청된 작업들은 다아래와 같은 시간에 반환됩니다. 서버에 요청된 모든 작업들은 30초 내에 처리됩니다.

- 0초 - 작업 1,2,3 요청
- 10초 - 작업 1 완료,
- 20초 - 작업 2 완료,
- 30초 - 작업 3 완료

### 동기와 비동기의 비교

**동기 처리**는 설계가 매우 간단하고, 직관적이다는 장점이 있습니다. 그러나, 불필요한 대기 시간이 발생할 수 있어 자원을 비효율적으로 사용할 수 있습니다.

**비동기 처리**는 대기시간 없이 요청들을 처리할 수 있다는 장점이 있습니다. 다만, 설계가 복잡해 사용하기 어렵다는 단점이 있습니다.

동기와 비동기는 서로를 좋고 나쁘다로 나눌 수 없다고 생각합니다. 상황에 따라 적합한 처리 방식을 선택하는게 개발자로써 중요할 것입니다.

## 4. 메세지 큐를 쓰는 이유에 대해서 2가지 예시를 서술해주세요.

메세지 큐의 사용 예시는 다음과 같은 2가지를 들 수 있습니다.
1. 비동기적인 실행(Asynchronous Invocation)
2. 분산 처리 시스템 구현.

### 비동기적인 실행 (async's Invocation)
 비동기적인 실행은 사용자의 요청에 대한 응답을 반환할 필요가 없는 경우에 적합한 처리 방식입니다. 예를들어 A라는 사용자가 블로그에 글을 게시할때를 가정해 보겠습니다. 이 블로그 사이트는 특별한 2개의 기능을 가지고 있습니다. 게시글을 올리면, A를 팔로우 하는 다른 사람들에게 알람이 전송됩니다. 게시된 글의 내용을 분석해 다른 사용자에게 추천을 해주는 기능도 있습니다.

A 사용자 입장에서 생각해보겠습니다. A는 게시글을 올릴 때, 게시글이 저장되었는지의 여부가 중요합니다. 글 내용 분석 작업이나 팔로워들에게 알람을 전송했는지의 여부는 A에게 중요하지 않습니다. 만약 저장 버튼을 눌렀을 때, 부가적인 기능들을 모두 수행한 후 저장한다면 수십초 이내에 저장 완료라는 피드백이 유저에게 전달될 것입니다. 유저는 이러한 피드백 지연에 불만을 가질것입니다. 대부분의 유저는 자신이 처리한 요청이 즉시 혹은 최대 500ms 이내에 처리되길 원합니다. 부가기능까지 모두 실행한 뒤 피드백을 제공하기엔 너무 늦습니다.

위와같은 상황에서 메시지 큐를 사용할 수 있습니다. 각 부가기능별로 한 개의 큐를 생성합니다. 다시 글 저장기능으로 돌아와, 유저가 저장 버튼을 눌렀을 때 부가적인 기능 실행에 필요한 정보를 앞서 생성한 큐로 전송합니다. 이후, 저장 완료라는 피드백을 반환합니다. 이 과정들은 대부분 수십 ms 이내로 처리될 것이기 때문에, 유저의 피드백 대기 체감시간은 영향을 받지 않을것입니다. 

이제 블로그 서비스는 메시지 큐를 통해 사용자를 오래 기다리게 하지 않으면서, 부가적인 기능을 처리할 수 있는 환경을 가졌습니다. 그렇다면 이제 사용자는 저장 완료라는 피드백을 받았다고 가정해보겠습니다. 2개의 부가기능에 대한 큐들은 처리를 위한 데이터를 가지고 있습니다. 이 데이터들은 각 큐를 바라보고 있는 wokrer를 통해 처리할 수 있습니다. worker는 주기적으로 큐를 폴링하면서 데이터의 존재 유무를 확인합니다. 데이터가 존재하면, 일정 단위로 데이터를 가져와(consume) 처리하고, 결과를 서비스에 반환합니다.

큐를 사용한 비동기적 처리를 통해 즉시 처리해야 할 부분 / 별도로 처리하는 부분 / 즉각적인 피드벡 제공등의 이점을 얻을 수 있습니다. 즉시 처리해 결과를 반환해야하는 상황이 아니라면 대규모 시스템에서는 큐를 사용한 비동기적 실행 아키텍처를 고려할 수 있을것입니다.

비동기적인 실행
